'''Main :program:`valjean` executable.'''

import sys
import argparse
import pkgutil
import importlib
import logging

from . import commands
from .commands.eval import make_eval_test_task
from .. import LOGGER, LOG_FILE_FORMAT, __version__
from ..config import Config


def main(argv=None):
    '''Main entry point for the :program:`valjean` executable.'''
    if argv is None:
        argv = sys.argv[1:]
    LOGGER.debug('arguments: %s', argv)

    parser = make_parser()
    args = parser.parse_args(argv)
    LOGGER.debug('parsed args: %s', args)

    config = process_options(args)

    if hasattr(args, 'func'):
        # collect stuff from valjean.py
        job_file = config.get('path', 'job-file')
        priority = getattr(args.func.__self__, 'PRIORITY', None)
        targets = args.targets if hasattr(args, 'targets') else set()
        collected_tasks = collect_tasks(job_file, args.job_args, priority,
                                        targets, args.test_prefix)
        args.func(args, collected_tasks, config)
    else:
        parser.print_help()


def collect_tasks(job_file, job_args, priority, targets, test_prefix):
    '''Collect tasks from a job file, respecting the constraints specified on
    the command line.

    Classes deriving from :class:`~.Command` (which represent sub-commands of
    the :program:`valjean` executable) and those derived from :class:`~.Task`
    (which represent the different type of tasks that can be executed: checking
    out code, building it, running it...) may define a ``PRIORITY`` class
    attribute, which is expected to be an integer.  When the user specifies a
    sub-command to the :program:`valjean` executable, the :func:`collect_tasks`
    function will use the sub-command's priority to filter out the tasks that
    were generated by the user's job function; specifically, only tasks with a
    priority smaller than or equal to the sub-command priority will be kept,
    (along with their dependencies).  This allows partial execution of the
    dependency graph.

    Some sub-commands (e.g. :class:`~.GraphCommand` and
    :class:`~.TasksCommand`) do not have any ``PRIORITY`` attribute.
    :func:`collect_tasks` does not apply any filtering when these sub-commands
    are invoked.

    The real filtering work is done in :func:`filter_tasks`.
    :func:`collect_tasks` returns the tasks returned by :func:`filter_tasks`
    and all of their dependencies.

    :param str job_file: the name of the file containing the `job()` function.
    :param list(str) job_args: the list of arguments to be passed to the
        `job()` function.
    :param int priority: the largest priority of the tasks that will be
        executed.
    :param targets: a (possibly empty) collection of task names. This
        represents any task names that the user specifies on the command line.
    :type targets: set(str)
    :param str test_prefix: tasks whose name starts with this prefix are
        expected to produce tests (in the sense of the
        :class:`~.gavroche.test.Test` class).
    :returns: the collected tasks.
    :rtype: list(Task)
    '''

    # import the job file and run the job() function
    tasks = run_job(job_file, job_args)

    # compute the transitive closure of the dependency graph for the tasks
    # returned by job()
    tasks = tasks_and_dependencies(tasks)
    LOGGER.debug('all tasks: %s', tasks)

    check_unique_task_names(tasks)

    # detect tasks that produce Test objects and add an EvalTestTask for each
    # of them
    tasks = eval_test_tasks(tasks, test_prefix)

    # remove tasks that were not requested
    tasks = filter_tasks(tasks, targets, priority)

    # call tasks_and_dependencies() again to close the dependency graph (some
    # dependencies may have been suppressed by filtering)
    tasks = tasks_and_dependencies(tasks)
    LOGGER.debug('collected tasks: %s', tasks)
    return tasks


def run_job(job_file, job_args):
    '''Run the `job()` function from the specified job file and return its
    result.

    :param str job_file: the name of the file containing the `job()` function.
    :param list(str) job_args: the list of arguments to be passed to the
        `job()` function.
    :returns: whatever `job()` returns; expected to be a list of
        :class:`~.Task` objects.
    :rtype: list(Task)
    '''
    from ..dyn_import import dyn_import
    LOGGER.debug('importing job-file: %s', job_file)
    try:
        module = dyn_import(job_file)
    except FileNotFoundError:
        LOGGER.fatal('Cannot find job file %s', job_file)
        sys.exit(1)

    try:
        tasks = module.job(*job_args)
    except TypeError as err:
        if str(err).startswith('job()'):
            import inspect
            signature = inspect.getfullargspec(module.job)
            n_args = len(signature.args)
            new_msg = ('This valjean job expects exactly {} -a/--args '
                       'option(s)'.format(n_args))
            err = TypeError(new_msg)
        raise err
    LOGGER.debug('job tasks: %s', tasks)
    return tasks


def filter_tasks(tasks, targets, priority):
    '''Remove tasks that were not requested by the user; this includes any
    target that was not specified on the command line (if tasks were specified,
    that is) and tasks that are not supposed to be executed by the selected
    command (e.g. running ``valjean build`` should not execute
    :class:`~.RunTask` tasks). Tasks are filtered based on the ``PRIORITY``
    mechanism, which is described in the documentation for
    :func:`collect_tasks`.

    :param tasks: the list of tasks.
    :type tasks: list(Task)
    :param targets: a collection of task names.
    :type targets: set(str)
    :param priority: the largest priority of the tasks that will be executed;
        see the `PRIORITY` class attribute of class derived from
        :class:`~.Command`.
    :type priority: int or None
    :returns: the tasks that pass the cut, as a list.
    :rtype: list(Task)
    '''
    LOGGER.debug('action priority: %s', priority)
    if targets:
        def _filter(task):
            '''Only keep specified tasks.'''
            return task.name in targets
    else:
        def _filter(_task):
            '''Keep all tasks, regardless of their name.'''
            return True

    tasks = [task for task in tasks
             if (priority is None or task.PRIORITY <= priority)
             and _filter(task)]
    LOGGER.debug('filtered tasks: %s', tasks)
    return tasks


def tasks_and_dependencies(tasks):
    '''Return the tasks along with all their dependencies.

    :param list tasks: A list of tasks.
    :returns: The list of tasks, their dependencies, the dependencies of their
              dependencies and so on.
    :rtype: list(Task)
    '''
    queue = set(tasks)
    all_tasks = queue.copy()
    while queue:
        deps = set(dep for task in queue for dep in task.depends_on
                   if task.depends_on is not None)
        all_tasks.update(deps)
        queue = deps
    return list(all_tasks)


def check_unique_task_names(tasks):
    '''Check that the tasks have unique names.

    :param list tasks: A list of tasks.
    :raises ValueError: if two or more tasks have the same name.
    '''
    names = set()
    dups = set()
    for task in tasks:
        if task.name in names:
            dups.add(task.name)
        names.add(task.name)
    if dups:
        dups_str = '\n  '.join(dups)
        err = ('Task names must be unique; the following task names appear '
               'more than once:\n  {}'.format(dups_str))
        raise ValueError(err)


def eval_test_tasks(tasks, test_prefix):
    '''Create test-evaluation tasks for any task whose name starts with the
    given prefix.

    :param tasks: a list of tasks.
    :type tasks: list(Task)
    :param str test_prefix: a prefix identifying tasks that produce tests.
    :returns: the tasks in `tasks`, plus one evaluation task for each task
        whose name matches the given prefix.
    :rtype: list(Task)
    '''
    ret_tasks = tasks.copy()
    for task in tasks:
        if task.name.startswith(test_prefix):
            eval_task = make_eval_test_task(task)
            ret_tasks.append(eval_task)
    return ret_tasks


def make_parser():
    '''Construct the argument parser.'''
    parser = argparse.ArgumentParser(prog='valjean')

    # -V/--version
    version_string = '%(prog)s ' + __version__
    parser.add_argument('-V', '--version', action='version',
                        version=version_string,
                        help='show the code version number and exit')
    parser.add_argument('-v', '--verbose', action='count',
                        help='increase verbosity')
    parser.add_argument('-c', '--config', action='append',
                        help='use the specified configuration file; '
                        'may be specified multiple times')
    parser.add_argument('-l', '--log', help='path to the log file')
    parser.add_argument('-a', '--args', action='append',
                        default=[], dest='job_args',
                        help='arguments that will be passed to the job() '
                        'function; may be specified multiple times')
    parser.add_argument('--test-prefix', default='test_',
                        help='valjean assumes that tasks whose name starts '
                        'with this string produce tests')
    parser.add_argument('--env-path', action='store', default='valjean.tasks',
                        help='path to the file containing the persistent '
                        'environment (default: valjean.tasks)')
    parser.add_argument('--env-skip-read', action='store_true',
                        help='do not read the environment from the path '
                        'specified by --env_path at the beginning of the run')
    parser.add_argument('--env-skip-write', action='store_true',
                        help='do not write the environment to the path '
                        'specified by --env_path at the end of the run')
    parser.add_argument('--env-format', action='store',
                        choices=('pickle',), default='pickle',
                        help='environment persistency format')

    # here come the subcommands
    cmd_parsers = parser.add_subparsers(title='Valid commands',
                                        dest='command_name')

    # import each submodule in commands.* and create a new subparser for it
    prefix = commands.__name__ + '.'
    submods_iter = pkgutil.iter_modules(commands.__path__)
    cmd_objs = []
    for _, modname, _ in submods_iter:
        cmd_name = modname.capitalize() + 'Command'
        module = importlib.import_module(prefix + modname)
        cmd_cls = getattr(module, cmd_name)
        cmd_obj = cmd_cls()
        cmd_objs.append(cmd_obj)

    # sort the commands by increasing priority; put commands without priority
    # (e.g. graph at the end of the list)
    max_priority = max(cmd_obj.PRIORITY for cmd_obj in cmd_objs
                       if hasattr(cmd_obj, 'PRIORITY'))
    cmd_objs.sort(key=lambda cmd_obj: getattr(cmd_obj, 'PRIORITY',
                                              max_priority + 1))
    for cmd_obj in cmd_objs:
        cmd_parser = cmd_parsers.add_parser(cmd_obj.NAME,
                                            help=cmd_obj.HELP,
                                            aliases=cmd_obj.ALIASES)
        cmd_obj.register(cmd_parser)

    return parser


def process_options(args):
    '''Process the parsed options.

    :returns: The configuration.'''

    # configuration file
    config = Config(paths=args.config)

    # verbosity
    if args.verbose is not None:
        if args.verbose >= 1:
            log_level = logging.DEBUG
    else:
        log_level = logging.INFO
    LOGGER.setLevel(log_level)
    for handler in LOGGER.handlers:
        handler.setLevel(log_level)

    # log to file
    if args.log is not None:
        formatter = logging.Formatter(LOG_FILE_FORMAT,
                                      datefmt='%Y-%m-%d %H:%M:%S')
        handler = logging.FileHandler(args.log)
        handler.setFormatter(formatter)
        handler.setLevel(log_level)
        LOGGER.addHandler(handler)

    return config
